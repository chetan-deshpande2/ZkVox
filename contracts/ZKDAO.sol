// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IVerifier {
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[4] memory input
    ) external view returns (bool);
}

contract ZKDAO {
    IVerifier public verifier;

    /**
     * @dev The scalar field prime for BN254 used by Groth16.
     * Any public input passed to the verifier MUST be less than this to avoid overflow attacks.
     */
    uint256 constant FIELD_PRIME =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;

    // We store the results here. vote=1 is Yes, vote=0 is No.
    mapping(uint256 => uint256) public yesVotes;
    mapping(uint256 => uint256) public noVotes;

    // To prevent double voting, we track the nullifierHash generated by the circuit.
    mapping(uint256 => bool) public nullifiers;

    // The current state of the membership tree.
    // NOTE: In a production environment, this would be updated via a Merkle tree manager or bridge.
    uint256 public merkleRoot;

    event VoteCast(uint256 indexed proposalId, uint256 vote);
    event RootUpdated(uint256 newRoot);

    constructor(address _verifier, uint256 _merkleRoot) {
        verifier = IVerifier(_verifier);
        merkleRoot = _merkleRoot;
    }

    /**
     * @notice Allows updating the valid membership root.
     * TODO: Add access control (e.g. OnlyOwner or Timelock) to this function.
     */
    function updateRoot(uint256 _newRoot) external {
        merkleRoot = _newRoot;
        emit RootUpdated(_newRoot);
    }

    /**
     * @notice Submit a privacy-preserving vote.
     * @param a, b, c The Groth16 proof components.
     * @param nullifierHash Unique hash for (identity, proposal) to prevent double voting.
     * @param proposalId The ID of the proposal being voted on.
     * @param root The Merkle root this proof was generated against.
     * @param vote The actual vote choice (0 or 1).
     */
    function castVote(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256 nullifierHash,
        uint256 proposalId,
        uint256 root,
        uint256 vote
    ) external {
        // First, basic range checks to ensure we're within the scalar field.
        require(nullifierHash < FIELD_PRIME, "Input overflow: nullifierHash");
        require(proposalId < FIELD_PRIME, "Input overflow: proposalId");
        require(root < FIELD_PRIME, "Input overflow: root");
        require(vote < FIELD_PRIME, "Input overflow: vote");

        // Proof must be generated against the current membership set.
        require(
            root == merkleRoot,
            "Root mismatch: Membership state has changed"
        );

        // One identity, one vote per proposal.
        require(!nullifiers[nullifierHash], "Security: Double voting detected");

        // The public inputs must match the order in components/main of vote.circom
        // Signals: [root, nullifierHash, proposalId, vote]
        uint256[4] memory publicSignals = [
            root,
            nullifierHash,
            proposalId,
            vote
        ];

        require(
            verifier.verifyProof(a, b, c, publicSignals),
            "ZK Error: Proof verification failed"
        );

        // If we're here, the proof is valid. Mark the nullifier and tally the vote.
        nullifiers[nullifierHash] = true;

        if (vote == 1) {
            yesVotes[proposalId]++;
        } else {
            noVotes[proposalId]++;
        }

        emit VoteCast(proposalId, vote);
    }
}
